/* autogenerated by Processing revision 1297 on 2025-06-13 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import controlP5.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class LatteArt extends PApplet {



PGraphics drawLayer;
PGraphics UILayer;
String exportFolder = sketchPath("exports");
ControlP5 cp5;
PImage mugOverlay;
FluidGrid fluid;
boolean overlayLoaded = false;
int simOffsetX = 66;
int simOffsetY = 137;

// Simulation parameters
int    N = 256;      // grid resolution
float  dt = 0.28f;    // time-step
int    ITER = 20;
float  currentMilkAmount;
float  currentForceAmount;
float  currentViscosity;
float  currentDiffusion;
int    brushSize;
float  renderExposure;
int    SCALE = 1; // 1 px per cell

int coffeeColor = color(100, 65, 23);
int milkColor   = color(250, 245, 230);

int mugRadius   = N / 2;
int mugCX       = (N + 2) / 2;
int mugCY       = mugCX;

Slider milkAmountSlider,
  forceAmountSlider,
  viscositySlider,
  diffusionSlider,
  exposureSlider,
  brushSizeSlider;

// buttons
boolean paused = false;      // current state
Toggle  pauseToggle;
boolean symmetryEnabled = false;
Toggle symmetryToggle;
boolean showAbout = false;
Button  closeAboutBtn;

public void settings() {
  size(700, 512);
}

public void setup() {
  currentMilkAmount  = 70;
  currentForceAmount = 0.0015f;
  currentViscosity   = 1f;
  currentDiffusion   = 0.0f;
  brushSize          = 8;
  renderExposure     = 95;

  mugOverlay = loadImage("data/overlay.png");
  overlayLoaded = (mugOverlay != null);
  fluid = new FluidGrid(N,
    currentDiffusion,
    currentViscosity,
    dt,
    ITER);

  drawLayer = createGraphics(700, 512);
  UILayer = createGraphics(700, 512);
  cp5 = new ControlP5(this);

  int uiX = (N + 2) * SCALE + 190;
  int uiY = 50;
  int w   = 160;
  int h   = 20;
  int step = 30;

  milkAmountSlider = cp5.addSlider("currentMilkAmount")
    .setPosition(uiX, uiY)
    .setSize(w, h)
    .setRange(1, 450)
    .setValue(currentMilkAmount)
    .setLabel("Milk Amount");

  uiY += step;
  forceAmountSlider = cp5.addSlider("currentForceAmount")
    .setPosition(uiX, uiY)
    .setSize(w, h)
    .setRange(0f, 0.03f)
    .setDecimalPrecision(4)
    .setValue(currentForceAmount)
    .setLabel("Force Amount");


  uiY += step;
  viscositySlider = cp5.addSlider("currentViscosity")
    .setPosition(uiX, uiY)
    .setSize(w, h)
    .setRange(0f, 1f)
    .setDecimalPrecision(4)
    .setValue(currentViscosity)
    .setLabel("Viscosity");

  uiY += step;
  diffusionSlider = cp5.addSlider("currentDiffusion")
    .setPosition(uiX, uiY)
    .setSize(w, h)
    .setRange(0.0f, 0.0001f)
    .setDecimalPrecision(6)
    .setValue(currentDiffusion)
    .setLabel("Milk Diffusion");

  uiY += step;
  exposureSlider  = cp5.addSlider("renderExposure")
    .setPosition(uiX, uiY)
    .setSize(w, h)
    .setRange(0, 98)
    .setValue(renderExposure)
    .setLabel("Render Exposure");

  uiY += step;
  brushSizeSlider  = cp5.addSlider("brushSize")
    .setPosition(uiX, uiY)
    .setSize(w, h)
    .setRange(5, 20)
    .setValue(brushSize)
    .setLabel("Brush Size");

  uiY += step * 2;
  cp5.addButton("resetFluidButton")
    .setPosition(uiX, uiY)
    .setSize(w, h + 10)
    .setLabel("Reset Milk")
    .setColorLabel(color(255))
    .setColorBackground(color(223, 83, 61))
    .setColorForeground(color(234, 137, 122));

  uiY += step * 2;
  pauseToggle = cp5.addToggle("paused")
    .setPosition(uiX, uiY)
    .setSize(w/4, h)
    .setMode(ControlP5.SWITCH)
    .setLabel("Pause")
    .setColorBackground(color(1, 173, 254))
    .setColorForeground(color(0, 46, 92))
    .setColorActive(color(0, 46, 92));

  uiX += 80;
  symmetryToggle = cp5.addToggle("symmetryEnabled")
    .setPosition(uiX, uiY)
    .setSize(w/4, h)
    .setValue(false)
    .setMode(ControlP5.SWITCH)
    .setLabel("Symmetry")
    .setColorBackground(color(1, 173, 254))
    .setColorForeground(color(0, 46, 92))
    .setColorActive(color(0, 46, 92));

  uiX -= 80;
  uiY += step * 2;
  cp5.addButton("exportPNGButton")
    .setPosition(uiX, uiY)
    .setSize(w, h + 10)
    .setLabel("Export PNG")
    .setColorForeground(color(111, 202, 108))
    .setColorBackground(color(91, 219, 87))
    .setColorLabel(color(0));

  uiY += step * 2;
  cp5.addButton("aboutButton")
    .setPosition(uiX, uiY)
    .setSize(w, h + 10)
    .setLabel("About");

  PFont myFont = createFont("Control Font", 12);
  Group aboutGroup = cp5.addGroup("aboutGroup")
    .setPosition(0, 0)
    .setSize(width, height)
    .setBackgroundColor(color(0, 160))
    .setBackgroundHeight(height)
    .hide();

  cp5.addTextarea("aboutText")
    .setGroup(aboutGroup)
    .setPosition(width/2 - 160, height/2 - 110)
    .setSize(320, 180)
    .setText("Latte Art Simulator\n"
    + "----------------------------------\n"
    + "Left mouse  –  pour milk\n"
    + "Right mouse –  erase milk\n"
    + "Pause btn   –  freezes/unfreezes simulation\n"
    + "Symmetry    -  toggles symmetry aroud Y axis\n"
    + "Reset milk  -  clears milk and resets flow grid\n"
    + "Sliders     -  as labels say\n"
    + "NOTE: if you increase brush size, it's recommended to decrease force and icrease milk amount\n"
    + "Export      –  exports PNG to (exports/)\n\n"
    + "© 2025 Timotej Dzugas")
    .setFont(myFont)
    .setColorBackground(color(0, 0))
    .setColorForeground(color(0, 0))
    .setColor(color(255));

  cp5.addButton("closeAboutBtn")
    .setGroup(aboutGroup)
    .setPosition(width/2 - 40, height/2 + 90)
    .setSize(80, 25)
    .setLabel("Close");
  println("Setup done.");
}

public void resetFluidButton() {
  fluid.reset();
  println("Fluid simulation reset.");
}

public void handleBrush() {
  boolean overSim =
    mouseX >= simOffsetX &&
    mouseX <  simOffsetX + drawLayer.width  &&
    mouseY >= simOffsetY &&
    mouseY <  simOffsetY + drawLayer.height;

  if (overSim && mousePressed) {
    int baseX = floor((mouseX - simOffsetX) / (float)SCALE);
    int baseY = floor((mouseY - simOffsetY) / (float)SCALE);
    int r2    = mugRadius * mugRadius;

    for (int dy = -brushSize; dy <= brushSize; dy++) {
      for (int dx = -brushSize; dx <= brushSize; dx++) {

        // skip offsets outside the circular mug
        int gx = baseX + dx - mugCX;
        int gy = baseY + dy - mugCY;
        if (gx*gx + gy*gy > r2) continue;
        // brush square -> circle
        if (dx*dx + dy*dy > brushSize * brushSize) continue;

        int cx = constrain(baseX + dx, 1, N);
        int cy = constrain(baseY + dy, 1, N);

        float amtX = (mouseX - pmouseX) * currentForceAmount;
        float amtY = (mouseY - pmouseY) * currentForceAmount;
        fluid.addVelocity(cx, cy, amtX, amtY);

        float cells = PI * brushSize * brushSize;
        float amountPerCell = currentMilkAmount / cells;
        if (mouseButton == LEFT) {

          fluid.addDensity(cx, cy, amountPerCell);
        } else if (mouseButton == RIGHT) {
          fluid.setDensity(cx, cy, 0);
        }
        if (symmetryEnabled) {
          int mirrorGX = 2 * mugCX - (baseX + dx);   // grid X mirrored
          int mirrorGY = baseY + dy;                 // same Y

          int mx = constrain(mirrorGX, 1, N);
          int my = constrain(mirrorGY, 1, N);
          int mgx = mx - mugCX;
          int mgy = my - mugCY;
          if (mgx * mgx + mgy * mgy <= r2) {

            // invert horizontal component of velocity
            fluid.addVelocity(mx, my, -amtX, amtY);

            if (mouseButton == LEFT) {
              fluid.addDensity(mx, my, amountPerCell);
            } else if (mouseButton == RIGHT) {
              fluid.setDensity(mx, my, 0);
            }
          }
        }
      }
    }
  }
}

public void handleSimulation() {
  drawLayer.beginDraw();
  drawLayer.clear();
  drawLayer.pushMatrix();
  drawLayer.translate(simOffsetX, simOffsetY);

  drawLayer.fill(coffeeColor);
  drawLayer.noStroke();
  drawLayer.rect(0, 0, drawLayer.width, drawLayer.height);

  if (!paused) fluid.step();

  fluid.renderD(drawLayer, SCALE, 98 - renderExposure);

  if (overlayLoaded) {
    drawLayer.imageMode(CORNER);
    drawLayer.image(mugOverlay,
      -simOffsetX,
      -simOffsetY);
  }
  drawLayer.popMatrix();
  drawLayer.endDraw();
}
public void draw() {
  handleBrush();
  handleSimulation();

  background(60);
  image(drawLayer, 0, 0);
  fill(255);
  textAlign(LEFT, TOP);
  textSize(12);
  text("FPS: " + nf(frameRate, 0, 1),
    width - 90, height - 30);
}

public void exportPNGButton() {
  File dir = new File(exportFolder);
  if (!dir.exists()) dir.mkdirs();

  String fname = String.format("latte-%04d-%02d-%02d-%02d-%02d-%02d.png",
    year(), month(), day(), hour(), minute(), second());

  drawLayer.save(exportFolder + "/" + fname);
  println("Saved " + fname + "  →  " + exportFolder);
}

public void aboutButton() {
  cp5.getGroup("aboutGroup").show();
}

public void closeAboutBtn() {
  cp5.getGroup("aboutGroup").hide();
}
// The linear solver, and other functions for liquid simulation are taken from https://mikeash.com/pyblog/fluid-simulation-for-dummies.html
// with modifications to make it 2D and adapt to my usecase (f.e. renderExposure)


class FluidGrid {
  int N;          // Size of the grid (active cells)
  int iter;       // Solver iterations

  float dt;       // Timestep
  float diff;     // Diffusion rate
  float visc;     // Viscosity

  float[] s;      // Scratch space for density
  float[] density; // Density of "milk"

  float[] Vx;     // Velocity x-component
  float[] Vy;     // Velocity y-component
  float[] Vx0;    // Previous velocity x
  float[] Vy0;    // Previous velocity y

  FluidGrid(int N_val, float diffusion, float viscosity, float dt_val, int iter_val) {
    this.N = N_val;
    this.diff = diffusion;
    this.visc = viscosity;
    this.dt = dt_val;
    this.iter = iter_val;

    int gridSize = (N + 2) * (N + 2); // Total cells including boundaries
    this.s = new float[gridSize];
    this.density = new float[gridSize];

    this.Vx = new float[gridSize];
    this.Vy = new float[gridSize];
    this.Vx0 = new float[gridSize];
    this.Vy0 = new float[gridSize];
  }

  public int IX(int x, int y) {
    x = constrain(x, 0, N + 1);
    y = constrain(y, 0, N + 1);
    return x + y * (N + 2);
  }

  public void addDensity(int x, int y, float amount) {
    if (x >= 1 && x <= N && y >= 1 && y <= N) { // Only add to active grid cells
        this.density[IX(x, y)] += amount;
        this.density[IX(x, y)] = max(0, this.density[IX(x, y)]); // Optional: prevent negative density from accumulation if amount can be negative
    }
  }

  public void setDensity(int x, int y, float value) {
    if (x >= 1 && x <= N && y >= 1 && y <= N) { // Only modify active grid cells
      this.density[IX(x, y)] = value;
    }
  }

  public void addVelocity(int x, int y, float amountX, float amountY) {
     if (x >= 1 && x <= N && y >= 1 && y <= N) { // Only add to active grid cells
        int index = IX(x, y);
        this.Vx[index] += amountX;
        this.Vy[index] += amountY;
    }
  }

  public void step() {
    // Store current velocities in Vx0, Vy0 to use as "previous" state for diffusion/advection
    System.arraycopy(Vx, 0, Vx0, 0, Vx.length);
    System.arraycopy(Vy, 0, Vy0, 0, Vy.length);
    System.arraycopy(density, 0, s, 0, density.length); // s becomes prev_density

    // Velocities
    diffuse(1, Vx0, Vx, visc, dt, iter, N); // Output to Vx0
    diffuse(2, Vy0, Vy, visc, dt, iter, N); // Output to Vy0

    project(Vx0, Vy0, Vx, Vy, iter, N); // Vx,Vy are p, div scratch. Output to Vx0, Vy0

    advect(1, Vx, Vx0, Vx0, Vy0, dt, N);  // Advect using projected Vx0,Vy0, output to Vx
    advect(2, Vy, Vy0, Vx0, Vy0, dt, N);  // Advect using projected Vx0,Vy0, output to Vy

    project(Vx, Vy, Vx0, Vy0, iter, N);   // Project current Vx,Vy. Output to Vx, Vy

    // Density
    // s already holds previous density state from System.arraycopy above
    diffuse(0, s, density, diff, dt, iter, N); // Diffuse current density, use s for scratch, output to s (new diffused state)
    advect(0, density, s, Vx, Vy, dt, N);     // Advect the diffused state (in s) using current velocities, output to density
    clipToCircle((N + 2)/2, (N + 2)/2, N/2);  
}

  // magic 
  public void lin_solve(int b, float[] x, float[] x0, float a, float c, int iter_val, int N_active) {
    float cRecip = 1.0f / c;
    for (int k = 0; k < iter_val; k++) {
      for (int j = 1; j <= N_active; j++) {
        for (int i = 1; i <= N_active; i++) {
          x[IX(i, j)] =
            (x0[IX(i, j)]
            + a * (x[IX(i + 1, j)]
            + x[IX(i - 1, j)]
            + x[IX(i, j + 1)]
            + x[IX(i, j - 1)]
            )) * cRecip;
        }
      }
      set_bnd(b, x, N_active);
    }
  }

  public void diffuse(int b, float[] x, float[] x0, float diff_rate, float dt_val, int iter_val, int N_active) {
    // x is the array to be filled (e.g. Vx0 from step), x0 is the source (e.g. Vx from step)
    float a = dt_val * diff_rate * (N_active * N_active);
    lin_solve(b, x, x0, a, 1 + 4 * a, iter_val, N_active);
  }

  public void project(float[] velocX_in, float[] velocY_in, float[] p_scratch, float[] div_scratch, int iter_val, int N_active) {
    // velocX_in, velocY_in are the velocities to be projected (modified in place)
    // p_scratch, div_scratch are temporary arrays (passed as Vx, Vy from step())

    for (int j = 1; j <= N_active; j++) {
      for (int i = 1; i <= N_active; i++) {
        div_scratch[IX(i, j)] = -0.5f * (
          velocX_in[IX(i + 1, j)]
          - velocX_in[IX(i - 1, j)]
          + velocY_in[IX(i, j + 1)]
          - velocY_in[IX(i, j - 1)]
          ) / N_active;
        p_scratch[IX(i, j)] = 0;
      }
    }
    set_bnd(0, div_scratch, N_active);
    set_bnd(0, p_scratch, N_active);
    lin_solve(0, p_scratch, div_scratch, 1, 4, iter_val, N_active);

    for (int j = 1; j <= N_active; j++) {
      for (int i = 1; i <= N_active; i++) {
        velocX_in[IX(i, j)] -= 0.5f * (p_scratch[IX(i + 1, j)] - p_scratch[IX(i - 1, j)]) * N_active;
        velocY_in[IX(i, j)] -= 0.5f * (p_scratch[IX(i, j + 1)] - p_scratch[IX(i, j - 1)]) * N_active;
      }
    }
    set_bnd(1, velocX_in, N_active);
    set_bnd(2, velocY_in, N_active);
  }

  public void advect(int b, float[] d_out, float[] d_in, float[] velocX_field, float[] velocY_field, float dt_val, int N_active) {
    // d_out is the array to be filled (e.g. Vx from step), d_in is the source (e.g. Vx0 from step)
    float i0_f, i1_f, j0_f, j1_f; // _f for float
    float dtx = dt_val * N_active;
    float dty = dt_val * N_active;

    float s0, s1, t0, t1;
    float tmp1, tmp2, current_x_coord_f, current_y_coord_f; // _f for float

    float Nfloat = N_active;
    float ifloat, jfloat; // Loop counters as floats
    // int i, j; // Loop counters as ints (already parameter or local)

    for (int j_int = 1, j = 1; j_int <= N_active; j_int++, j++) {
      jfloat = j;
      for (int i_int = 1, i = 1; i_int <= N_active; i_int++, i++) {
        ifloat = i;
        tmp1 = dtx * velocX_field[IX(i_int, j_int)];
        tmp2 = dty * velocY_field[IX(i_int, j_int)];
        current_x_coord_f = ifloat - tmp1;
        current_y_coord_f = jfloat - tmp2;

        if (current_x_coord_f < 0.5f) current_x_coord_f = 0.5f;
        if (current_x_coord_f > Nfloat + 0.5f) current_x_coord_f = Nfloat + 0.5f;
        i0_f = floor(current_x_coord_f);
        i1_f = i0_f + 1.0f;

        if (current_y_coord_f < 0.5f) current_y_coord_f = 0.5f;
        if (current_y_coord_f > Nfloat + 0.5f) current_y_coord_f = Nfloat + 0.5f;
        j0_f = floor(current_y_coord_f);
        j1_f = j0_f + 1.0f;

        s1 = current_x_coord_f - i0_f;
        s0 = 1.0f - s1;
        t1 = current_y_coord_f - j0_f;
        t0 = 1.0f - t1;

        int i0i = (int)i0_f;
        int i1i = (int)i1_f;
        int j0i = (int)j0_f;
        int j1i = (int)j1_f;

        d_out[IX(i_int, j_int)] =
          s0 * (t0 * d_in[IX(i0i, j0i)] + t1 * d_in[IX(i0i, j1i)]) +
          s1 * (t0 * d_in[IX(i1i, j0i)] + t1 * d_in[IX(i1i, j1i)]);
      }
    }
    set_bnd(b, d_out, N_active);
  }

  public void set_bnd(int b, float[] x, int N_active) {
    for (int i = 1; i <= N_active; i++) {
      x[IX(0, i)]     = b == 1 ? -x[IX(1, i)] : x[IX(1, i)];
      x[IX(N_active + 1, i)] = b == 1 ? -x[IX(N_active, i)] : x[IX(N_active, i)];
      x[IX(i, 0)]     = b == 2 ? -x[IX(i, 1)] : x[IX(i, 1)];
      x[IX(i, N_active + 1)] = b == 2 ? -x[IX(i, N_active)] : x[IX(i, N_active)];
    }

    x[IX(0, 0)] = 0.5f * (x[IX(1, 0)] + x[IX(0, 1)]);
    x[IX(0, N_active + 1)] = 0.5f * (x[IX(1, N_active + 1)] + x[IX(0, N_active)]);
    x[IX(N_active + 1, 0)] = 0.5f * (x[IX(N_active, 0)] + x[IX(N_active + 1, 1)]);
    x[IX(N_active + 1, N_active + 1)] = 0.5f * (x[IX(N_active, N_active + 1)] + x[IX(N_active + 1, N_active)]);
  }

  public void renderD(PGraphics pg, int r_scale, float exposure) {
    pg.noStroke();
    for (int j = 1; j <= N; j++) {
      for (int i = 1; i <= N; i++) {
        float d = density[IX(i, j)];
        if (d > 0.01f) {
          float lerp = constrain(d / exposure, 0, 1);
          pg.fill(lerpColor(coffeeColor, milkColor, lerp));
          pg.rect(i * r_scale, j * r_scale, r_scale, r_scale);
        }
      }
    }
  }

  public void reset() {
    int size = (N + 2) * (N + 2);
    for (int i = 0; i < size; i++) {
      density[i] = s[i] = 0;
      Vx[i] = Vy[i] = Vx0[i] = Vy0[i] = 0;
    }
  }


  public void clipToCircle(int cx, int cy, int rad) {
    int r2 = rad * rad;
    for (int j = 1; j <= N; j++) {
      for (int i = 1; i <= N; i++) {
        int d2 = (i - cx)*(i - cx) + (j - cy)*(j - cy);
        if (d2 > r2) {                // outside mug
          int idx = IX(i,j);
          density[idx] = 0;
          Vx[idx] = Vy[idx] = 0;
        }
      }
    }
  }
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "LatteArt" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
